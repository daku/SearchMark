<html>
<head>
<script language="Javascript" type="text/javascript">
    
// background.html: SearchMark back-end
//
// Copyright (C) 2010  Akshay Dua, and Candy Yiu
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
    
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see http://www.gnu.org/licenses/.
  
// =============== GLOBALS ==============

// Bookmarked page database
var SearchMarkDB = {};

// Status indicator variables
var gRemainingSearch = 0;

// Communicate with extension UI
var gPort;

// Used to highlight searched keywords in results
var uiHighlightStart = '<span class=ContentTextHighLight>';
var uiHighlightEnd = '</span>';

// ======================== DATABASE API ==================

// Open the database
SearchMarkDB.db = null;
SearchMarkDB.open = function()
{
    var dbSize = 200 * 1024 * 1024; // 200 MB
    SearchMarkDB.db =
        openDatabase('SearchMarkDB', '1.0', 'Bookmark Page Storage', dbSize);
}

// create the table that stores all the bookmark
// info, including the associated pages.
SearchMarkDB.createTable =
    function() 
{
    SearchMarkDB.db.transaction(
        function(tx)
        {
            tx.executeSql('CREATE VIRTUAL TABLE pages ' + 
                          'USING fts3(id INTEGER PRIMARY KEY, ' + 
                          'url TEXT, title TEXT, page TEXT)',
                          [],
                          getCallback("create table", "pages", 1),
                          getCallback("create table", "pages", 0));

            tx.executeSql('CREATE TABLE IF NOT EXISTS ' + 
                          'rawpages (id INTEGER PRIMARY KEY, htmlpage TEXT)',
                          [],
                          getCallback("create table", "rawpages", 1),
                          getCallback("create table", "rawpages", 0));
        });
}

// add a bookmark and associated page to the database
SearchMarkDB.addBookmarkedPage =
    function(newId, newUrl, newTitle, newPlainPage, newHtmlPage)
{
    SearchMarkDB.db.transaction(
        function(tx)
        {
            // html-free page for searching
            tx.executeSql('INSERT INTO pages(id, url, title, ' + 'page) ' + 
                          'VALUES (?,?,?,?)',
                          [ newId, newUrl, newTitle, newPlainPage ],
                          getCallback("insert page", newId + " " +
                                      newUrl, 1), 
                          getCallback("insert page", newId + " " +
                                      newUrl, 0)); 

            // html page for showing cached version
            tx.executeSql('INSERT INTO rawpages(id, htmlpage) ' +
                          'VALUES (?,?)', 
                          [newId, newHtmlPage ], 
                          getCallback("insert page", "raw " + newId +
                                      " " + newUrl, 1),  
                          getCallback("insert page", "raw " + newId +
                                      " " + newUrl, 0)); 
        });
}

// remove a bookmarked page from the database
SearchMarkDB.removeBookmarkedPage =
    function(theId)
{
    SearchMarkDB.db.transaction(
        function(tx)
        {
            tx.executeSql('DELETE FROM pages WHERE id=?', [ theId ], 
                          getCallback("remove page", theId, 1), 
                          getCallback("remove page", theId, 0));

            tx.executeSql('DELETE FROM rawpages WHERE id=?', [ theId ], 
                          getCallback("remove page", "raw " + theId, 1), 
                          getCallback("remove page", "raw " + theId, 0));
        });
}

// update an already stored bookmarked page
SearchMarkDB.updateBookmarkedPage =
    function(theId, theUrl, theTitle, thePlainPage, theHtmlPage)
{
    SearchMarkDB.db.transaction(
        function(tx)
        {
            tx.executeSql('UPDATE pages SET url=?, ' + 
                          'title=?, page=? WHERE id=?',
                          [ theUrl, theTitle, thePlainPage, theId ],
                          getCallback("update bookmark", theUrl, 1),
                          getCallback("update bookmark", theUrl, 0));

            tx.executeSql('UPDATE rawpages SET htmlpage=? WHERE id=?',
                          [ theHtmlPage, theId ],
                          getCallback("update bookmark", "raw " + theUrl, 1),
                          getCallback("update bookmark", "raw " + theUrl, 0));
        });
}

// get all bookmark URLs. Callback function can
// be provided use the results as necessary.
SearchMarkDB.getStoredBookmarks =
    function()
{
    SearchMarkDB.db.transaction(
        function(tx)
        {
            tx.executeSql('SELECT id,url,title FROM pages',
                          [],
                          getCallback("show db", "pages", 1),
                          getCallback("show db", "pages", 0));

            tx.executeSql('SELECT id FROM rawpages',
                          [],
                          getCallback("show db", "raw", 1),
                          getCallback("show db", "raw", 0));
        });
}

// Supports the cached page feature. Returns cached raw html page.
SearchMarkDB.getRawHtmlPage = 
    function (id, callback)
{
    SearchMarkDB.db.transaction(
        function(tx)
        {
            tx.executeSql('SELECT htmlpage FROM rawpages ' +
                          'WHERE id = ?',
                          [id],
                          callback,
                          getCallback("get page", "raw", 0));
        });
}

SearchMarkDB.doSearch =
    function(callback, keywords)
{
    SearchMarkDB.db.transaction(
        function(tx)
        {
            tx.executeSql('SELECT id,url,title, ' + 
                          'snippet(pages, "' + uiHighlightStart +
                          '", "' + uiHighlightEnd + '") ' +
                          'as snippet FROM pages WHERE ' + 
                          'pages MATCH ' + keywords,
                          [],
                          callback,
                          getCallback("search", "pages", 0));
        });
}

// clear all stored information.
SearchMarkDB.clear =
    function()
{
    SearchMarkDB.db.transaction(
        function(tx)
        {
            tx.executeSql('DELETE FROM pages', [], 
                          getCallback("clear table", "pages", 1), 
                          getCallback("clear table", "pages", 0));

            tx.executeSql('DELETE FROM rawpages', [], 
                          getCallback("clear table", "rawpages", 1), 
                          getCallback("clear table", "rawpages", 0));
        });
}

// remove the table and all stored information
SearchMarkDB.purge =
    function()
{
    SearchMarkDB.db.transaction(
        function(tx)
        {
          tx.executeSql('DROP TABLE pages', [], 
                        getCallback("delete table", "pages", 1), 
                        getCallback("delete table", "pages", 0));

          tx.executeSql('DROP TABLE rawpages', [], 
                        getCallback("delete table", "rawpages", 1), 
                        getCallback("delete table", "rawpages", 0));
        });
}

// ================== INIT ===============

// open the database each time extension loads.
SearchMarkDB.open();
console.debug("Opened SearchMark database.");

// SearchMarkDB.getStoredBookmarks();
// SearchMarkDB.clear();
// SearchMarkDB.purge();
// localStorage['initialized'] = "no";

// initialize once only. Populate the database
// by retrieving and storing bookmarked pages, and
// URLs. If initialized but want to reinitialize,
// just set localStorage['initialized'] to "no".
if (!localStorage['initialized'] || localStorage['initialized'] !=
    "yes") {
    SearchMarkDB.createTable();

    chrome.bookmarks.getTree(
        function(bookmarks)
        {
    	    initBookmarkDatabase(bookmarks);
        });

    localStorage['initialized'] = "yes";
}

// ========================== CORE ===============

chrome.browserAction.onClicked.addListener(
    function(tab)
    {
        chrome.tabs.create( 
            {'url' : 'SearchMarkUI.html'}, 
            function(newTab) {});
    });

chrome.extension.onRequest.addListener(handleRequest);

chrome.bookmarks.onChanged.addListener(
    function(id, changeInfo)
    {
        if (localStorage['initialized'] != "yes")
            return;

        getAndStoreBookmarkContent( 
            {id : id, 
             url : changeInfo.url,
             title : changeInfo.title}, 
            SearchMarkDB.updateBookmarkedPage);
    });

chrome.bookmarks.onCreated.addListener(
    function(id, newBookmark)
    {
        if (localStorage['initialized'] != "yes")
            return;

        getAndStoreBookmarkContent( {
            id : id,
            url : newBookmark.url,
            title : newBookmark.title
        }, SearchMarkDB.addBookmarkedPage);
    });

chrome.bookmarks.onRemoved.addListener(
    function(id, removeInfo)
    {
        if (localStorage['initialized'] != "yes")
            return;

        SearchMarkDB.removeBookmarkedPage(id);
    });

// experimental APIs require user to start chrome with a specific option
// flag from the command line. So, not using for now.
// chrome.experimental.omnibox.onInputEntered.addListener(
//     function(keywords) {
//         handleRequest({method: 'search', keywords: keywords},
//                       background, function() {});
//     }
// );

// ================= CORE API ===================

function handleRequest(request, sender, callback)
{
    if (request.method == 'search') {
        gPort = chrome.extension.connect( {name : "uiToBackend"});

        console.debug("search " + request.keywords);

        searchBookmarkedPages("'" + request.keywords + "'");
        
        callback();
    } else if (request.method == 'cached') {
        SearchMarkDB.getRawHtmlPage(request.bookmarkid, displayRawPage);

        console.debug("cache request " + request.bookmarkid);

        callback();
    } else {
        callback();
    }
}

function displayRawPage(tx, r)
{
    if(r.rows.length) {

        chrome.tabs.create(
            {url: 'rawPageView.html', selected: true}, 
            function (tab)
            {
                // connect to tab that will show the raw page
                var port = chrome.extension.connect({name:
                "rawPageView"});
                
                // send the raw page
                port.postMessage(r.rows.item(0).htmlpage);

                // done.
                port.disconnect();
            });

    } else {
        console.log("Unexpected error: this page should have " + 
                    "been cached. Please file a bug report " + 
                    "at <todo:put github url here>");
    }
}

function informUIResultsDone()
{
    var result = {};

    result.matchType = "DONE";

    gPort.postMessage(result);

    // cleanup
    gRemainingSearch = 0;

    gPort.disconnect();
}

function searchBookmarkedPagesCb(tx, r)
{
    gRemainingSearch = r.rows.length;
    var result = {};

    for ( var i = 0; i < r.rows.length; i++) {
        result.id = r.rows.item(i).id;
        result.url = r.rows.item(i).url;
        result.title = r.rows.item(i).title;
        result.text = r.rows.item(i).snippet;
        result.matchType = "page";

        gPort.postMessage(result);

        gRemainingSearch--;
    }

    if (!gRemainingSearch) {
        informUIResultsDone();
    }
}

function removeHTMLfromPage(page)
{
    // reduce spaces, remove new lines
    var pagetxt = page.replace(/\s+/gm, " ");

    // remove 'script', 'head', 'style' tags
    pagetxt = pagetxt.replace(/<\s*?head.*?>.*?<\s*?\/\s*?head\s*?>/i, " ");
    pagetxt = pagetxt.replace(/<\s*?script.*?>.*?<\s*?\/\s*?script\s*?>/gi, " ");
    pagetxt = pagetxt.replace(/<\s*?style.*?>.*?<\s*?\/\s*?style\s*?>/gi, " ");

    // Now remove other tags
    pagetxt = pagetxt.replace(/<.*?\/?>/g, " ");

    // Remove symbols
    pagetxt = pagetxt.replace(/&.*?;/g, " ");

    // Remove comment markers
    pagetxt = pagetxt.replace(/(<!--|-->)/g, " ");

    // After all the filtering, need to fix up spaces again
    pagetxt = pagetxt.replace(/\s+/gm, " ");

    return pagetxt;
}

function searchBookmarkedPages(keywords)
{
    SearchMarkDB.doSearch(searchBookmarkedPagesCb, keywords);
}

function getAndStoreBookmarkContent(bookmark, storeInDB)
{
    try {
        var xhr = new XMLHttpRequest();
        xhr.open("GET", bookmark.url, true);
        xhr.onreadystatechange = function()
        {
            try {
                if (this.readyState == 4) {

                    var pageNoHtml = removeHTMLfromPage(this.responseText);

                    // add page to database
                    storeInDB(bookmark.id, bookmark.url,
                              bookmark.title, pageNoHtml,
                              this.responseText);

                    this.abort();
                }
            } catch (e) {
                console.log(e.message);
                storeInDB(bookmark.id, bookmark.url, bookmark.title,
                          "", "");
            }
        }

        xhr.send();
    } catch (e) {
        console.log(e.message + bookmark.url);
        storeInDB(bookmark.id, bookmark.url, bookmark.title, "", "");
    }
}

function initBookmarkDatabase(bookmarks)
{
    bookmarks.forEach(
        function(bookmark)
        {
            if (bookmark.url && 
                bookmark.url.match("^https?://*")) 
            { // url exists and is well formed
                console.debug("Adding " + bookmark.url);
                getAndStoreBookmarkContent(bookmark,
                                           SearchMarkDB.addBookmarkedPage);
            } else {
                console.debug("Skipping. " + bookmark.url);
            }

            if (bookmark.children)
                initBookmarkDatabase(bookmark.children);
        });
}

function getCallback(cbname, msg, type)
{
    switch (cbname) {
    case "show db":
        if (type == 1)
            return function(tx, r)
        {
            for ( var i = 0; i < r.rows.length; i++) {
                console.log("Stored. " + msg + " " +
                            r.rows.item(i).url);
            }
        }
        else
            return function(tx, r)
        {
            console.debug("failed: " + cbname + " " + msg);
            console.log("  " + e.message);
        }            
        break;
    default:
        if (type == 1) // success callback
            return function(tx, r)
        {
            console.debug("succeded: " + cbname + " " + msg);
        }
        else
            // failure callback
            return function(tx, e)
        {
            console.debug("failed: " + cbname + " " + msg);
            console.log("  " + e.message);
        }
    }
}
</script>
</head>
</html>
